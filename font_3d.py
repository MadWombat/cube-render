from pathlib import Path

import numpy as np
import tensorflow as tf
import solid as s

from PIL import Image, ImageDraw, ImageFont


def render2d(txt, ttf_file, size, pad=0):
    if not Path(ttf_file).exists():
        raise ValueError("font file %s doesn't exist" % ttf_file)
    font = ImageFont.truetype(ttf_file, size=size - pad)
    text = Image.new('1', font.getsize(txt), 0)  # black by default
    draw = ImageDraw.Draw(text)
    draw.text((0, 0), txt, fill=1, font=font)
    text = text.crop(text.getbbox())
    image = Image.new('1', (size, size), 0)
    tw, th = text.size
    pos_x = (size - tw) // 2
    pos_y = (size - th) // 2
    image.paste(text, (pos_x, pos_y))
    return image


def create_model(size):
    return tf.keras.models.Sequential([
        tf.keras.layers.InputLayer(input_shape=(1, )),
        tf.keras.layers.Dense(256, activation='relu'),
        tf.keras.layers.Dense(256, activation='relu'),
        tf.keras.layers.Dense(size ** 3),
        tf.keras.layers.Reshape([size, size, size])
    ])


@tf.function
def loss(y_true, y_pred):
    """
    y_true is of shape [3, size, size] with three expected views of the cube
    y_pred is of shape [size, size, size], the cube generated by the model
    """
    x = tf.losses.kld(y_true[0][0], tf.reduce_sum(y_pred[0], axis=0))
    y = tf.losses.kld(y_true[0][1], tf.reduce_sum(y_pred[0], axis=1))
    z = tf.losses.kld(y_true[0][2], tf.reduce_sum(y_pred[0], axis=2))
    return x + y + z


class AlwaysTheSame(tf.keras.utils.Sequence):
    def __init__(self, data, size=1000):
        self._size = size
        self._data = data

    def __len__(self):
        return self._size

    def __getitem__(self, idx):
        return np.array([1, ]), np.array([[data, data, data], ])


def generate(model):
    cube = model.predict([1, ])[0]
    cube *= (1.0/cube.max())
    cube = np.abs(cube)
    cube = np.where(cube > 0.5, 1, 0)
    return cube


def to_space(cube):
    space = np.array(cube.nonzero()).transpose()
    return frozenset([tuple(x) for x in list(space)])


def get_ns(point, space):
    (x, y, z) = point
    friends = [
        (x + 1, y, z),
        (x - 1, y, z),
        (x, y + 1, z),
        (x, y - 1, z),
        (x, y, z + 1),
        (x, y, z - 1),
    ]
    return [x for x in friends if x in space]


def cleanup(space):
    space = set(space)
    while True:
        delete = set()
        for x in space:
            if len(get_ns(x, space)) in (0, 1, 6):
                delete.add(x)
        if not delete:
            break
        space = space.difference(delete)
    return list(space)


def to3d(space):
    voxels = []
    for (x, y, z) in space:
        voxels.append(s.translate([x*10, y*10, z*10])(s.cube(10)))
    return s.union()(*voxels)


if __name__ == '__main__':
    symb = 'A'
    size = 128
    ttf = '/Library/Fonts/Comic Sans MS.ttf'
    img = render2d(symb, ttf, size)
    data = np.array(img.getdata())
    data = data.reshape([size, size])
    model = create_model(size)
    model.compile(optimizer='adam', loss=loss)
    gen = AlwaysTheSame(data)
    model.fit_generator(gen, shuffle=False)
    model.save('cubeA.hdf5')
